using System.Collections.Immutable;
using System.Reflection;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

namespace NetWebAssemblyTSTypeGenerator.Tests
{
    public class GeneratorTest : IDisposable
    {
        private readonly List<string> _emitTempDir;
        private const string TestAssemblyName = "testassembly";

        public GeneratorTest()
        {
            _emitTempDir = new List<string>();
        }

        public void Dispose()
        {
            foreach (var d in _emitTempDir)
            {
                try
                {
                    var di = new DirectoryInfo(d);
                    foreach (var fi in di.GetFiles())
                    {
                        fi.Delete();
                    }
                    di.Delete();
                }
                catch (Exception)
                {
                    //
                }
            }

            GC.SuppressFinalize(this);
        }

        private static string GetTempDirectory()
        {
            var tempDirPath = Path.Combine(Path.GetTempPath(), Path.GetRandomFileName());
            Directory.CreateDirectory(tempDirPath);
            return tempDirPath;
        }

        [Fact]
        public void BaseGeneratorTest()
        {
            var outputDir = GetTempDirectory();
            _emitTempDir.Add(outputDir);

            var input = CreateCompilation(@"
using System;
using System.Runtime.InteropServices.JavaScript;

return 0;

namespace MyCode
{
    public partial class MyClass
    {
        [JSExport]
        internal static string Hello()
        {
            return ""Hello"";
        }

        [JSImport(""my.awesome.module"", ""main.mjs"")]
        internal static partial string FooBar();
    }
}
");

            GeneratorDriver driver = CSharpGeneratorDriver.Create(
                new[] { new NetWebAssemblyTSTypeGenerator() },
                optionsProvider: new CustomAnalyzerConfigOptionsProvider(
                    new CustomAnalyzerConfigOptions(
                        new Dictionary<string, string>{
                            { Constants.BuildPropertyJSPortOverrideTypeDefinitionOutputDir, outputDir},
                            { "build_property.AssemblyName", TestAssemblyName }
                        }.ToImmutableDictionary()
                    )
                )
            );

            driver.RunGeneratorsAndUpdateCompilation(input, out var _ /* outputCompilation */, out var diagnostics);

            Assert.True(diagnostics.IsEmpty, string.Join(',', diagnostics.Select(v => v.GetMessage())));
            // NOTE: Cannot use JSImport, JSExport attribute because it could not reference assemblies...
            // so outputCompilation.GetDiagnostics().IsEmpty will false

            var outputFileName = Path.Combine(outputDir, $"index.d.ts");
            Assert.True(File.Exists(outputFileName));

            var outputFileContent = File.ReadAllText(outputFileName);
            Assert.Contains(@$"/** Generated: for {TestAssemblyName}.dll */", outputFileContent);
            Assert.Contains(@$"export const getTypedAssemblyExports: (originalGetAssemblyExports: Promise<any>)", outputFileContent);
            var exportedJsonContent = string.Join("\n",
                outputFileContent.Split('\n')
                    .SkipWhile(v => v != "/* AutoGeneratedExportsHelperStart */")
                    .Skip(1)
                    .TakeWhile(v => v != "/* AutoGeneratedExportsHelperEnd */")).Trim();

            Assert.True(exportedJsonContent == @"{
  ""MyCode"": {
    ""MyClass"": {
      ""Hello"": () => any /* TODO */
    }
  }
}", exportedJsonContent);

            Assert.Contains(@$"export const setTypedModuleImports: <T extends ImportModuleNames>", outputFileContent);
            Assert.Contains("type ImportModuleNames = 'main.mjs'", outputFileContent);
            Assert.Contains("type ImportModuleValues<T extends ImportModuleNames>", outputFileContent);
            Assert.Contains("T extends 'main.mjs'", outputFileContent);
            Assert.Contains(@"{
  ""my"": {
    ""awesome"": {
      ""module"": () => any /* TODO */
    }
  }
}", outputFileContent);
        }

        // FIXME: TargetArchitecture, TargetOS, RuntimeIdentifier...how to use wasm-tools???
        private static Compilation CreateCompilation(string source)
            => CSharpCompilation.Create("compilation",
                new[] { CSharpSyntaxTree.ParseText(source) },
                new[] { MetadataReference.CreateFromFile(typeof(Binder).GetTypeInfo().Assembly.Location) },
                new CSharpCompilationOptions(OutputKind.ConsoleApplication));
    }
}
