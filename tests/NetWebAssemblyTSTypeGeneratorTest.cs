using System.Collections.Immutable;
using System.Reflection;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

namespace NetWebAssemblyTSTypeGenerator.Tests
{
    public class GeneratorTest : IDisposable
    {
        private readonly List<string> _emitTempDir;
        private const string TestAssemblyName = "testassembly";

        public GeneratorTest()
        {
            _emitTempDir = new List<string>();
        }

        public void Dispose()
        {
            foreach (var d in _emitTempDir)
            {
                try
                {
                    var di = new DirectoryInfo(d);
                    foreach (var fi in di.GetFiles())
                    {
                        fi.Delete();
                    }
                    di.Delete();
                }
                catch (Exception)
                {
                    //
                }
            }

            GC.SuppressFinalize(this);
        }

        private static string GetTempDirectory()
        {
            var tempDirPath = Path.Combine(Path.GetTempPath(), Path.GetRandomFileName());
            Directory.CreateDirectory(tempDirPath);
            return tempDirPath;
        }

        [Fact]
        public void BaseGeneratorTest()
        {
            var outputDir = GetTempDirectory();
            _emitTempDir.Add(outputDir);

            var input = CreateCompilation(@"
using System;
using System.Runtime.InteropServices.JavaScript;

return 0;

namespace MyCode
{
    public partial class MyClass
    {
        [JSExport]
        internal static string Hello()
        {
            return ""Hello"";
        }
    }
}
");

            GeneratorDriver driver = CSharpGeneratorDriver.Create(
                new[] { new NetWebAssemblyTSTypeGenerator() },
                optionsProvider: new CustomAnalyzerConfigOptionsProvider(
                    new CustomAnalyzerConfigOptions(
                        new Dictionary<string, string>{
                            { Constants.BuildPropertyJSPortOverrideTargetProjectInheritRuntimeType, "false"},
                            { Constants.BuildPropertyJSPortOverrideTypeDefinitionOutputDir, outputDir},
                            { "build_property.AssemblyName", TestAssemblyName }
                        }.ToImmutableDictionary()
                    )
                )
            );

            driver.RunGeneratorsAndUpdateCompilation(input, out var _ /* outputCompilation */, out var diagnostics);

            Assert.True(diagnostics.IsEmpty);
            // NOTE: Cannot use JSImport, JSExport attribute because it could not reference assemblies...
            // so outputCompilation.GetDiagnostics().IsEmpty will false

            var outputFileName = Path.Combine(outputDir, $"dotnet.{TestAssemblyName}.override.d.ts");
            Assert.True(File.Exists(outputFileName));

            var outputFileContent = File.ReadAllText(outputFileName);
            Assert.Contains(@$"export type ExportsHelper = (assemblyName: ""{TestAssemblyName}.dll"")", outputFileContent);
            var jsonContent = string.Join("\n",
                outputFileContent.Split('\n')
                    .SkipWhile(v => v != "/* AutoGeneratedExportsHelperStart */")
                    .Skip(1)
                    .TakeWhile(v => v != "/* AutoGeneratedExportsHelperEnd */")).Trim();

            Assert.True(jsonContent == @"{
  ""MyCode"": {
    ""MyClass"": {
      ""Hello"": () => any /* TODO */
    }
  }
}", jsonContent);
        }

        // FIXME: TargetArchitecture, TargetOS, RuntimeIdentifier...how to use wasm-tools???
        private static Compilation CreateCompilation(string source)
            => CSharpCompilation.Create("compilation",
                new[] { CSharpSyntaxTree.ParseText(source) },
                new[] { MetadataReference.CreateFromFile(typeof(Binder).GetTypeInfo().Assembly.Location) },
                new CSharpCompilationOptions(OutputKind.ConsoleApplication));
    }
}
